load('wind.mat')
load('Axbxh.mat')

vha = 2.81;
vz = 1.23;
psi_dot_m = 0.263;

x0 = 60;
y0 = 20;
z0 = -100;
psi0 = -3*pi/4;

T = -z0/vz;

psi_d = pi/4;

lambda1 = 100;
lambda2 = 10;

hold on
grid on
box on
axis equal
scatter(y0, x0, 50, 'k','filled')
scatter(0,0,100,'green','filled','d')

set(gca,'FontSize',20);
xlabel('\rightarrow East')
ylabel('\rightarrow North')

if_pontryagin = 0;
if_scp = 0;
if_nonlinear = 1;

%% Pontryagin's minimum principle

if if_pontryagin
    % wind accommodation
    Delta_s = zeros(2,wind_pf_size);
    for i = 2:wind_pf_size
        Delta_s(:,i) = 1/vz*[trapz(heights(1:i), wind_profile(1, 1:i));
                             trapz(heights(1:i), wind_profile(2, 1:i))];
    end
    x0w = x0 + interp1(heights, Delta_s(1,:),-z0,'linear','extrap');
    y0w = y0 + interp1(heights, Delta_s(2,:),-z0,'linear','extrap');
    scatter(y0w, x0w, 40, 'b','filled')
    
    % define
    v0 = vha/vz;
    um = psi_dot_m/vz;
    
    % solving
    tic
    p_0_guess = [0,0,0];
    [p_0_star, residual, flag] = fminsearch(@(p0) ComputeErr(p0, [x0w, y0w, psi0], -z0, v0, um, psi_d, lambda1, lambda2), p_0_guess, optimset('TolFun',1e-7,'TolX',1e-7,'MaxFunEvals',1e5,'MaxIter',1e5));
    h_span = linspace(0, -z0, 2000);
    X0 = [x0w; y0w; psi0; p_0_star'];
    [time, path] = ode45(@(h,x) ODEdyn(h, x, v0, um), h_span, X0);
    toc
    
    title("Guidance generated by Pontryagin's minimum principle")

    % wind-free guidance
    plot(path(:,2), path(:,1),'b--','LineWidth',1.5)
    
    % ground-frame guidance
    plot(path(:,2) - interp1(heights, Delta_s(2,:), linspace(-z0,0,2000),'linear','extrap')', ...
         path(:,1) - interp1(heights, Delta_s(1,:), linspace(-z0,0,2000),'linear','extrap')','r','LineWidth',1.5)
end


%% Sequential convex programming
if if_scp

    % setup
    N = 200;
    dt = -z0/vz/N;
    hs = linspace(-z0, 0, N+1);
    ws = [interp1(heights, wind_profile(1,:), hs, 'linear','extrap');
          interp1(heights, wind_profile(2,:), hs, 'linear','extrap')];
    eps = 0.1;
    MAX_ITER = 15;
    last_cost = Inf;
    
    % record time cost and loss of each iteration
    timecosts = [];
    loss = [];
    
    % SCP
    yalmip('clear')
    x = sdpvar(2,N+1);
    u = sdpvar(2,N+1);
    
    % x0, u0
    Cons = [x(:,1) == [x0; y0], u(:,1) == [vha*cos(psi0); vha*sin(psi0)]];
    objective = lambda1*x(:,end)'*x(:,end)+lambda2*(1-[cos(psi_d)/vha, sin(psi_d)/vha]*u(:,end));
    
    % x1~N
    for i = 2:N+1
        Cons = [Cons, x(:,i)==x(:,i-1)+dt*(u(:,i-1)+ws(:,i-1)), ...
                      (u(:,i)-u(:,i-1))'*(u(:,i)-u(:,i-1)) <= (psi_dot_m*vha*dt)^2, ...
                       u(:,i)'*u(:,i) <= (vha + eps)^2];
        objective = objective + 1/(vha^2*dt)*(u(:,i)-u(:,i-1))'*(u(:,i)-u(:,i-1));
    end
    
    u_last = [vha*cos(psi0);
              vha*sin(psi0)] * ones(1,N+1);
    
    colors = colormap(jet);
    title("Guidance generated by Sequential convex programming")

    for n = 1:MAX_ITER
        color = colors(floor(256/MAX_ITER*n),:);
    
        constraints = Cons;
        for i = 2:N+1
%             constraints = [constraints, (u_last(:,i)/vha)'*u(:,i) >= (vha-eps)];
            constraints = [constraints, (u_last(:,i)./vecnorm(u_last))'*u(:,i) >= (vha-eps)];
        end
        
        options = sdpsettings('verbose',0,'solver','ecos');
        tic
        sol = optimize(constraints,objective,options);
        toc
        timecosts = [timecosts, round(toc,2)];
        
        if sol.problem == 1 % infeasible
            disp("[ERROR] Infeasible at iteration "+num2str(n));
            break
        else
            current_cost = value(objective);
            loss = [loss, current_cost];

            if abs(current_cost - last_cost) < 0.1 % converged
                xs = value(x);
                us = value(u);
                disp("At iteration "+num2str(n)+", final cost: "+num2str(current_cost))
                plot(xs(2,:), xs(1,:),'Color',color,'LineWidth',1.5,'LineStyle','-')
                break
            else
                xs = value(x);
                us = value(u);
                plot(xs(2,:), xs(1,:),'Color',color,'LineWidth',1.5,'LineStyle','--')
                disp("At iteration "+num2str(n)+", current cost: "+num2str(current_cost))
                u_last = us;
            end
            last_cost = current_cost;
        end
    end
    
%     % ----------- stage 2 ------------
%     yalmip('clear')
%     x = sdpvar(2,N+1);
%     u = sdpvar(2,N+1);
%     eps_v = sdpvar(1,1);
%     
%     u_last = us;
%     lambda3 = 10000;
%     
%     % x0, u0
%     Cons = [x(:,1) == [x0; y0], u(:,1) == [vha*cos(psi0); vha*sin(psi0)], 0 <= eps_v(1) <= eps];
%     objective = lambda1*x(:,end)'*x(:,end)+lambda2*(1-[cos(psi_d)/vha, sin(psi_d)/vha]*u(:,end))+lambda3*eps_v;
%     
%     % x1~N
%     for i = 2:N+1
%         Cons = [Cons, x(:,i)==x(:,i-1)+dt*(u(:,i-1)+ws(:,i-1)), ...
%                       (u(:,i)-u(:,i-1))'*(u(:,i)-u(:,i-1)) <= (psi_dot_m*vha*dt)^2, ...
%                       (u_last(:,i)/vha)'*u(:,i) >= (vha-eps_v), ...
%                       norm(u(:,i)) <= (vha +eps_v)];
%         objective = objective + 1/(vha^2*dt)*(u(:,i)-u(:,i-1))'*(u(:,i)-u(:,i-1));
%     end
% 
%     for n = 1:MAX_ITER    
%         constraints = Cons;
%         for i = 2:N+1
%             constraints = [constraints, (u_last(:,i)/vha)'*u(:,i) >= (vha-eps_v)];
%         end
%         
%         options = sdpsettings('verbose',0,'solver','ecos');
%         tic
%         sol = optimize(constraints,objective,options);
%         toc
%         
%         if sol.problem == 1 % infeasible
%             disp("[ERROR] Infeasible at iteration "+num2str(n));
%             break
%         else
%             current_cost = value(objective);
%             if abs(current_cost - last_cost) < 0.1 % converged
%                 xs = value(x);
%                 us = value(u);
%                 disp("At iteration "+num2str(n)+", final cost: "+num2str(current_cost))
%                 plot(xs(2,:), xs(1,:),'r','LineWidth',1.5,'LineStyle','-')
%                 break
%             else
%                 xs = value(x);
%                 us = value(u);
%                 disp("At iteration "+num2str(n)+", current cost: "+num2str(current_cost))
%                 plot(xs(2,:), xs(1,:),'r','LineWidth',1.5,'LineStyle','-')
%                 u_last = us;
%             end
%             last_cost = current_cost;
%         end
%     end
    
    figure (2)
    subplot(1,2,1)
    hold on
    grid on
    box on
    set(gca,'FontSize',20);
    title('Loss of each SCP iteration')
    xlabel('iterations')
    ylabel('loss')
    scatter(linspace(1,size(loss,2),size(loss,2)), loss, 50, 'k','filled')
    plot(linspace(1,size(loss,2),size(loss,2)), loss, 'k','LineWidth',1.5)
    subplot(1,2,2)
    hold on
    grid on
    box on
    set(gca,'FontSize',20);
    title('Time cost of each SCP iteration')
    xlabel('iterations')
    ylabel('time cost [s]')
    scatter(linspace(1,size(timecosts,2),size(timecosts,2)), timecosts, 'k','filled')
    plot(linspace(1,size(timecosts,2),size(timecosts,2)), timecosts, 'k','LineWidth',1.5)

end


%% Nonlinear programming

if if_nonlinear
    N = 200;
    dt = -z0/vz/N;
    hs = linspace(-z0, 0, N+1);
    ws = [interp1(heights, wind_profile(1,:), hs, 'linear','extrap');
          interp1(heights, wind_profile(2,:), hs, 'linear','extrap')];
    
    % Obstacle-free set
    inds = zeros(size(Axbxh,1),1); % turn h to index
    for i = 1:size(Axbxh,1)
        inds(i) = find(hs<Axbxh(i,4),1);
    end
    
    % Optimization Start
    title("Guidance generated by Casadi+Ipopt")
    
    tic
    Au = [1; -1];
    bu = [psi_dot_m; psi_dot_m];
%     psi_dot_now = 0;
    
    Prob = casadi.Opti();
    x = Prob.variable(3, N+1);
    u = Prob.variable(1, N);
    
    
    % costs and constraints
    cost = lambda1*(x(1,end)^2 + x(2,end)^2) + lambda2*(x(3,end)-psi_d)^2;
    
    % x0, u0
    Prob.subject_to(x(:,1) == [x0; y0; psi0]);
%     Prob.subject_to(u(1) == psi_dot_now);
    
    % x1~xN, u1~uN
    for i = 2:N+1
        Prob.subject_to(x(:,i) == x(:,i-1) + dt*[vha*cos(x(3,i-1)) + ws(1,i-1);
                                                 vha*sin(x(3,i-1)) + ws(2,i-1);
                                                 u(i-1)]);
        cost = cost + u(i-1)^2*dt;
        Prob.subject_to(Au*u(i-1) <= bu); % control input constraints
    end
    
    % constraints of safezone
    for j = 1:size(Axbxh,1)
        % x_ind ~ xN
        for k = inds(j):N
            Prob.subject_to(Axbxh(j,1:2)*x(1:2,k) <= Axbxh(j,3));
        end
    end
    
    Prob.minimize(cost)
    Prob.solver('ipopt', struct('print_time', 0), struct('print_level', 0));
    
    % solve the guidance problem & give output
    try
        sol = Prob.solve();
    
        xs = sol.value(x);
        us = sol.value(u);
        plot(xs(2,:), xs(1,:),'r','LineWidth',1.5)
        pos_cost = lambda1*(xs(1,end)^2 + xs(2,end)^2);
        if pos_cost>400
            flag = false;
            guidance = zeros(5, N);
            disp("reject bad guidance!")
        else
            flag = true;
            guidance(1:2,1:N) = xs(1:2,1:N);
            guidance(3,1:N) = hs(1:N);
            guidance(4,1:N) = xs(3,1:N);
            guidance(5,1:N) = us(1:N);
        end
    
    catch
        disp("ERROR! Guidance solver failed!!")
        flag = false;
        guidance = zeros(5, N);  
    end
    toc
    
    if x0 == -60 && y0 == -20 % hard code
        origin_lat = 47.35504; % degree
        origin_lon = 8.51982; % degree
        PA = LatLon2xy(47.35422, 8.51943, origin_lat, origin_lon);
        PB = LatLon2xy(47.35544, 8.51869, origin_lat, origin_lon);
        PC = -PA;
        PD = -PB;
        points = [PA, PB, PC, PD, PA];
        fill3(points(2,:), points(1,:),zeros(5,1),'g','FaceAlpha',.3)
    end
end














%% Other functions
% dynamics
function dxdh = ODEdyn(h, x, v0, um) % x = [x, y, psi, p1, p2, p3]^T
    if(x(6) >= 2*um)
        u = -um;
    elseif(x(6) > -2*um)
        u = -x(6)/2;
    else
        u = um;
    end
    dxdh = [v0*cos(x(3));
            v0*sin(x(3));
            u;
            0;
            0;
            x(4)*v0*sin(x(3)) - x(5)*v0*cos(x(3))];
end

% error compare
function err = ComputeErr(p0, init_pose, h, v0, um, psi_d, lambda1, lambda2)
    h_span = linspace(0, h, 200);
    x0 = [init_pose(1);
          init_pose(2);
          init_pose(3);
          p0(1);
          p0(2);
          p0(3)];
    [~, path] = ode45(@(z,x) ODEdyn(z,x, v0, um), h_span, x0);
    err1 = (path(end,4) - 2*lambda1*path(end,1))^2;
    err2 = (path(end,5) - 2*lambda1*path(end,2))^2;
    err3 = (path(end,6) - 2*lambda2*(path(end,3)-psi_d))^2;
    err = err1 + err2 + err3;
end

function P = LatLon2xy(lat, lon, origin_lat, origin_lon)
    % define the average radius of the earth
    R = 6371000; % m
    
    % calculate the position in meters
    P = [(lat - origin_lat) / 180 * pi * R;
         (lon - origin_lon) / 180 * pi * R * cos(origin_lat / 180 * pi)];
end